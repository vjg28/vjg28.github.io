<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Varshil Gandhi</title>
    <link>https://vjg28.github.io/</link>
      <atom:link href="https://vjg28.github.io/index.xml" rel="self" type="application/rss+xml" />
    <description>Varshil Gandhi</description>
    <generator>Source Themes Academic (https://sourcethemes.com/academic/)</generator><language>en-us</language><lastBuildDate>Wed, 24 Jun 2020 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://vjg28.github.io/img/index.png</url>
      <title>Varshil Gandhi</title>
      <link>https://vjg28.github.io/</link>
    </image>
    
    <item>
      <title>Placement Experience | Microsoft Data Science</title>
      <link>https://vjg28.github.io/post/getting-started/</link>
      <pubDate>Wed, 24 Jun 2020 00:00:00 +0000</pubDate>
      <guid>https://vjg28.github.io/post/getting-started/</guid>
      <description>

&lt;p&gt;Hi, I am Varshil. I recently graduated from EEE dept, IIT Guwahati and am currently working as a Data &amp;amp; Applied Scientist at Microsoft. While documenting my placement experience, I realized that my story may not fit in the standard experience catalogue of people. I had varying priorities regarding placements &amp;amp; higher education, and the latter usually remained on the top all the time. Nevertheless, this article includes my personal story and lessons I learned throughout the placement season, which would be helpful for students applying for data science profiles in the upcoming placement season.&lt;/p&gt;

&lt;h2 id=&#34;why-data-science&#34;&gt;Why Data Science:&lt;/h2&gt;

&lt;p&gt;Coming to my experience with the placement process, starting with a clear view of the profiles to apply for is critical. The first question that needs answering is: Why pursue Data Science? And what do these roles fulfil? I personally think anyone having a knack for innovating &amp;amp; engineering products using data through recent advances in machine learning should definitely try. In short, data scientists are the middlemen that bring in state-of-the-art research and engineers it for the product improvisation. Moreover, for students interested in the research aspects of ML, these positions require keeping up with the state-of-the-art techniques and collaborating with research scientists, thus keeping up one’s exposure into the domain &amp;amp; assisting in higher studies.&lt;/p&gt;

&lt;h2 id=&#34;pre-test-preparations&#34;&gt;Pre-Test preparations:&lt;/h2&gt;

&lt;p&gt;When I started out, I was clear on which companies I would be targeting, and I directed my preparations accordingly. With my decision to go forward with both higher education &amp;amp; placement preparations, I went ahead only with companies having Data Science job profiles &amp;amp; targeted some individual companies working in ML even though the job position doesn’t explicitly mention Data Science. Before the tests, I majorly focused on revising &amp;amp; revisiting machine learning concepts (especially its application aspects), probability &amp;amp; linear algebra, solving puzzles and reviewing ML libraries in Python. Moreover, I also practised some coding problems covering the basics of data structures &amp;amp; algorithms from InterviewBit &amp;amp; GeeksForGeeks. I wasn’t able to devote a lot of time towards coding. Still, it is always better to practice more coding, as there are companies with Data Science profiles that conduct coding tests only. While my preparation in ML was based on 2+ years of experience in the same; it may not be the case for everyone. So, in the points below, I will go over some ‘before test preparation’ tips briefly.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Resume:

&lt;ul&gt;
&lt;li&gt;It is a critical part of the placement process. Some go-to tips I followed: Start your resume early on and always try keeping it concise, brief and explanatory; in one-page if possible. Describe your internships and projects such that even a layman can grasp the idea with little understanding of the topic. Avoid using complex terms, code names, etc unless it’s absolutely necessary. If one has multiple projects, only include those on which you can emphasize and show your contribution.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Portfolio:

&lt;ul&gt;
&lt;li&gt;For Data Science profiles, projects and internships in ML related domains matter a lot. Having great (personal &amp;amp; internship) projects, open-source contributions in famous ML libraries or packages, excellent Kaggle profile, and research papers will definitely help stand out of the crowd.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Machine Learning:

&lt;ul&gt;
&lt;li&gt;One would need a thorough understanding of machine learning algorithms, their theoretical aspects and applications. Along with it, basic knowledge of deep learning would also be a good addition. I used this &lt;a href=&#34;http://index-of.es/Varios-2/Hands%20on%20Machine%20Learning%20with%20Scikit%20Learn%20and%20Tensorflow.pdf&#34; target=&#34;_blank&#34;&gt;book&lt;/a&gt; as my go-to reference for ML concepts and applications. Apart from this, some companies ask coding problems on simple ML models based on regression and time-series data. For those, one should also require familiarity with machine learning libraries like pandas, scikit-learn, etc.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;test&#34;&gt;Test:&lt;/h2&gt;

&lt;p&gt;For Microsoft’s Data Scientist role, the test was MCQ based, consisting of around 60+ MCQs in 60 minutes. The test covered theoretical &amp;amp; application aspects of several topics in machine learning, such as regression, classification, decision trees, random forests, SVM, neural networks, generative/discriminative models and dimensionality reduction algorithms. Furthermore, it included some questions based on skip connections and language models, thus requiring a brief idea of essential concepts in deep learning. While the Microsoft test was solely MCQ based, some other tests actually needed us to code up solutions for ML problems in a short time frame. I also encountered questions on SQL and R language, but they are occasional and can be anticipated beforehand through the job description. For test preparation, I have shared a brief list of topics at the end of this article that covers up a vast majority of test &amp;amp; interview topics.&lt;/p&gt;

&lt;p&gt;Two days before the interviews, around 11 students were shortlisted for the interview process. For the SDE profile, Microsoft has a standard ‘Group Fly’ round a day before the interviews, where they give coding questions to solve and select a handful of students for the interviews. While in my case, we were informed that the ‘group fly’ round was not meant for Data Scientist profiles, and we moved forward to the interview process directly. 12 hours before the interviews, I revisited all my notes on ML algorithms, reviewed my resume and focused primarily on previous interview questions and case studies. Apart from that, I relaxed, chilled out and ate a lot of chocolates. :P&lt;/p&gt;

&lt;h2 id=&#34;interview&#34;&gt;Interview:&lt;/h2&gt;

&lt;p&gt;Coming to the interviews, the process had 3 rounds, all technical interviews and no HR round. In the first round, the interviewer asked me to choose any machine learning algorithm I liked and inquired more on its theoretical aspects. For some specific questions, he was expecting answers understandable to a layman. Below are some of the questions that were asked:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;How would you explain information gain in decision trees?
How would you design an anomaly detection algorithm using variants of decision trees?
Neural Networks &amp;amp; weight matrices, backpropagation
Questions related to Ensemble models and stacking.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second round was more of a case study. Firstly the interviewer asked me if I have worked on any projects that involve feature engineering. Then, he presented a problem, where one is expected to build a classification system that detects faults or bone cracks in high-resolution X-ray images while optimizing several other factors like time delay, cloud processing, scalability, need for local compute etc. With each idea I propose, he corrected and directed me towards a different aspect. The round went on for about 30 minutes or more on the same question. Though my final answer was not what he had expected, he was happy that I reached pretty close and kept churning out viable solutions.&lt;/p&gt;

&lt;p&gt;In the third round, the interviewer focused more on my projects &amp;amp; internships. The interviewer was observant &amp;amp; inquisitive towards my internships. As most of my projects involved reinforcement learning, he asked me about some mathematical formulations regarding the same. Moreover, he was curious about the motivation behind those projects. Finally, he started asking questions on ML algorithms &amp;amp; data pipelines, each more difficult than the last till I wasn’t able to answer. The final question where the interview ended was:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;How would you design a clustering algorithm using decision trees?
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Overall, all the interviewers were extremely friendly, polite and always entertained questions from my side. What I feel helped me a lot during the interview, apart from the core ML knowledge is my past experience on multiple related projects &amp;amp; internships. Revisiting those learning pathways during interviews adds practicality &amp;amp; strong support for the solution I propose. Apart from all that, keep your interview priorities straight and clear, be attentive &amp;amp; confident, and last but not least, be curious and learn from every experience.&lt;/p&gt;

&lt;p&gt;There is no foolproof way to crack data science interviews, but it is with one’s own experience and of others before that can help navigate the unknown. Enjoy the placements, learn from it, help your friends and don’t forget to smile throughout the process. &lt;strong&gt;May the force be with you!&lt;/strong&gt;&lt;/p&gt;

&lt;h2 id=&#34;list-of-ml-topics-to-review&#34;&gt;List of ML topics to review:&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Naive Bayes (Decision boundary)&lt;/li&gt;
&lt;li&gt;Linear &amp;amp; Logistic Regression&lt;/li&gt;
&lt;li&gt;Multi-class vs Multi-Label Classification&lt;/li&gt;
&lt;li&gt;SVM&lt;/li&gt;
&lt;li&gt;Decision Trees&lt;/li&gt;
&lt;li&gt;Random Forests&lt;/li&gt;
&lt;li&gt;Bias Variance Trade-Offs&lt;/li&gt;
&lt;li&gt;Time-Series Data Handling&lt;/li&gt;
&lt;li&gt;k-Means Clustering&lt;/li&gt;
&lt;li&gt;PCA, LDA, t-Sne&lt;/li&gt;
&lt;li&gt;L[1-inf] losses and their behaviours&lt;/li&gt;
&lt;li&gt;Metrics (Precision, Recall, ROC AUC, F1 Score, PR AUC)&lt;/li&gt;
&lt;li&gt;Regularization&lt;/li&gt;
&lt;li&gt;Backpropagation&lt;/li&gt;
&lt;li&gt;Ensemble Models&lt;/li&gt;
&lt;li&gt;Skip connections&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Inverse RL on Mountain Car Slides</title>
      <link>https://vjg28.github.io/slides/irl-slides/</link>
      <pubDate>Wed, 01 Apr 2020 00:00:00 +0000</pubDate>
      <guid>https://vjg28.github.io/slides/irl-slides/</guid>
      <description>

&lt;h1 id=&#34;irl-experiment-on-mountain-car&#34;&gt;IRL Experiment on Mountain Car&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://github.com/vjg28/Linear-Inverse-RL-algorithms&#34; target=&#34;_blank&#34;&gt;Code Application&lt;/a&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Inverse reinforcement learning&lt;/strong&gt; deals with the case of learning the reward function for a situation or an activity where the optimum behavior is known.













&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://vjg28.github.io/project/linear-inverse-rl/irl.png&#34; &gt;
&lt;img src=&#34;https://vjg28.github.io/project/linear-inverse-rl/irl.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;
&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;environment-details&#34;&gt;Environment Details&lt;/h2&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;https://vjg28.github.io/project/linear-inverse-rl/car.png&#34; &gt;
&lt;img src=&#34;https://vjg28.github.io/project/linear-inverse-rl/car.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;



&lt;/figure&gt;


&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Mountain car env&lt;/strong&gt; : A car (agent) learning how to get to the top of the cliff in the least timesteps.&lt;/li&gt;
&lt;li&gt;The goal of the agent is to reach the goal position , represented by the flag at position = 0.5 units.&lt;/li&gt;
&lt;li&gt;The state space is a vector  [position, velocity] with

&lt;ul&gt;
&lt;li&gt;1.2 ≤ position ≤ 0.6&lt;/li&gt;
&lt;li&gt;velocity∈[-0.07, 0.07]&lt;/li&gt;
&lt;li&gt;The above implies that the state space is continuous and infinite.&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;The agent can perform 3 actions 0 ,1 ,2 :

&lt;ul&gt;
&lt;li&gt;0: accelerate in the left&lt;/li&gt;
&lt;li&gt;1: zero acceleration&lt;/li&gt;
&lt;li&gt;2: accelerate in the right&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Acceleration = 0.001 units&lt;/li&gt;
&lt;li&gt;The reward function inbuilt the environment is $R(s,a) = -1$ for each timestep and 0 if it reaches the goal.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;experiment-details&#34;&gt;Experiment Details&lt;/h2&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;ng-abbel-paper-vs-ours-similarities&#34;&gt;NG- Abbel paper vs Ours (Similarities)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
A linear function approximator for reward function with 26 basis functions.
&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
A penalty function with penalty constant = 2 in the updates of linear programming.
&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
Equally spaced Gaussian functions as their reward basis functions.
&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
Reward function depend only on the ‘position’ feature of state.
&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;differences&#34;&gt;Differences:&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
Test in the paper was a naive approach (Algo 2). While ours in Algo 3.
&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
The paper discretized the state space $s= [position,~ velocity]$ into $120*120$  discrete states. This makes the number of states finite.
&lt;/span&gt;&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
They created a model based on the discretization of state space. We didn&amp;rsquo;t.
&lt;/span&gt;&lt;/li&gt;
&lt;li&gt;&lt;span class=&#34;fragment &#34; &gt;
They evaluated the Linear programming maximization for a bunch of 5000 states.
&lt;/span&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;results&#34;&gt;Results&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;To be added&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;questions&#34;&gt;Questions?&lt;/h1&gt;

&lt;p&gt;&lt;a href=&#34;https://discourse.gohugo.io&#34; target=&#34;_blank&#34;&gt;Ask&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://sourcethemes.com/academic/docs/&#34; target=&#34;_blank&#34;&gt;Documentation&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>AnimalAI - Imitation Learning</title>
      <link>https://vjg28.github.io/project/animal-ai/</link>
      <pubDate>Wed, 05 Feb 2020 04:11:01 +0530</pubDate>
      <guid>https://vjg28.github.io/project/animal-ai/</guid>
      <description></description>
    </item>
    
    <item>
      <title>ARLE- Autonomous Robot for Library Enhancement</title>
      <link>https://vjg28.github.io/project/arle/</link>
      <pubDate>Tue, 03 Dec 2019 04:11:01 +0530</pubDate>
      <guid>https://vjg28.github.io/project/arle/</guid>
      <description></description>
    </item>
    
    <item>
      <title>BERT on NarrativeQA</title>
      <link>https://vjg28.github.io/project/bert-on-narrativeqa/</link>
      <pubDate>Fri, 04 Oct 2019 02:10:38 +0530</pubDate>
      <guid>https://vjg28.github.io/project/bert-on-narrativeqa/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Fake News Detector</title>
      <link>https://vjg28.github.io/project/fake-news-detector/</link>
      <pubDate>Fri, 04 Oct 2019 02:03:16 +0530</pubDate>
      <guid>https://vjg28.github.io/project/fake-news-detector/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Policy Gradient Algorithms</title>
      <link>https://vjg28.github.io/project/lunar-lander-rl/</link>
      <pubDate>Fri, 04 Oct 2019 00:49:00 +0530</pubDate>
      <guid>https://vjg28.github.io/project/lunar-lander-rl/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Robotic Palm Control</title>
      <link>https://vjg28.github.io/project/robotic-palm/</link>
      <pubDate>Thu, 03 Oct 2019 03:54:18 +0530</pubDate>
      <guid>https://vjg28.github.io/project/robotic-palm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Linear Inverse RL Algorithms</title>
      <link>https://vjg28.github.io/project/linear-inverse-rl/</link>
      <pubDate>Thu, 03 Oct 2019 03:29:44 +0530</pubDate>
      <guid>https://vjg28.github.io/project/linear-inverse-rl/</guid>
      <description>

&lt;h2 id=&#34;inverse-reinforcement-learning&#34;&gt;Inverse Reinforcement Learning:&lt;/h2&gt;

&lt;p&gt;The core concept of reinforcement learning in Markov decision process revolves around the definition of &lt;strong&gt;reward values&lt;/strong&gt;. The agent observes a state, proceed with an action and the environment provides the reward and the next state.&lt;/p&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;RL_env.png&#34; data-caption=&#34;Agent-Environment interaction&#34;&gt;
&lt;img src=&#34;RL_env.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Agent-Environment interaction
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;p&gt;However, there are numerous cases where designing reward functions are complicated or &amp;lsquo;Mission Impossible&amp;rsquo;. For example, we want to train an RL agent to drive a car autonomously. The reward function can be hand-engineered, but creating such functions is often time consuming and sub-optimal. Given such reward functions, the agent may not be able to train for the given task.&lt;/p&gt;

&lt;p&gt;In numerous scenarios like the one mentioned above, the human knows the optimal way to perform the task (Expert policy) but do not understand the underlying reward function behind the task. So, we instead think of ways to use expert human policies instead of reward functions for an agent.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;The simplest of all is just copying the expert behaviour. Given expert trajectories, we design the learning process from a supervised learning perspective: Learn direct mapping from state to actions. This method is known as &lt;strong&gt;Behavior Cloning&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Instead of naive copying, can we recreate the reward function of the environment given expert behaviours? Yes. This approach of imitating an expert through learning the reward functions is known as &lt;strong&gt;Inverse Reinforcement Learning&lt;/strong&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;irl.png&#34; data-caption=&#34;RL vs Inverse RL&#34;&gt;
&lt;img src=&#34;irl.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    &lt;strong&gt;RL vs Inverse RL&lt;/strong&gt;
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;p&gt;The first IRL algorithm (known as Linear Inverse RL) was published in a paper &lt;a href=&#34;https://ai.stanford.edu/~ang/papers/icml00-irl.pdf&#34; target=&#34;_blank&#34;&gt;Algorithms for IRL&lt;/a&gt; (Ng &amp;amp; Russel 2000) in which they proposed an iterative algorithm to extract the reward function given optimal/expert behaviour policy for obtaining the goal in that particular environment. We will discuss in short what are the significant problems that Inverse RL algorithms face. But, notations first.&lt;/p&gt;

&lt;h3 id=&#34;notations&#34;&gt;Notations:&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;Markov decision process : $&amp;lt; S, А, P_{sa}, γ, R &amp;gt;$

&lt;ul&gt;
&lt;li&gt;Where $S$ = finite/infinite set of states&lt;/li&gt;
&lt;li&gt;$A$ = action set&lt;/li&gt;
&lt;li&gt;$P_{sa}$ = transition probability matrix&lt;/li&gt;
&lt;li&gt;γ = discount factor&lt;/li&gt;
&lt;li&gt;R = reward function&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;$π : S➝A $ is th policy function.&lt;/li&gt;
&lt;li&gt;$ V^{\pi}(s_t)=E[R(s_t)+R(s_{t+1})] $ Value function&lt;/li&gt;
&lt;li&gt;$ Q^π(s, a) = R(s) + γ * E_{s&amp;rsquo; \sim  P_{sa}}[ V^π(s’) ] $ Action value function&lt;/li&gt;
&lt;li&gt;$V^*(s)$ : optimal value function&lt;/li&gt;
&lt;li&gt;$Q^*(s, a)$ : optimal state value function&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The problem is to find a reward function for an environment given optimal behavior/policy. Now, given certain basic conditions, we can easily prove the theorm mentioned below.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Theorem 1&lt;/strong&gt;: Let $〈S, А, { Pa }, γ〉$ is known. Then, $π(s)≡a1$ is optimal if and only if for all $a∈ A-a1$ , the reward satisfies the equation
$$ (P_{a1} - P_a)(I - γ P_{a1})^{-1} R ≽ 0 $$&lt;/p&gt;

&lt;p&gt;See the problem in the above equation?&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s the &lt;strong&gt;degeneracy of reward functions&lt;/strong&gt;. Each policy has a large set of reward function for which the policy is optimal. The set even includes $R=0 ∀s∈S$. There are even more solutions other than these trivial ones. We do not want these trivial reward functions, as the agent will spend its entire lifetime iterating with 0 reward function and will not learn a thing. So how can we choose reward function from such a vast set of solutions?&lt;/p&gt;

&lt;h3 id=&#34;heuristics&#34;&gt;Heuristics :&lt;/h3&gt;

&lt;p&gt;We use some specific heuristics.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The natural way is to choose a reward function such that deviating from the policy on any single step must be as costly as possible. This intuition is represented in mathematical terms, as mentioned below. $$ ∑_{s∈S}( Q^π(s,a_1) -  max_{a∈A-a_1}Q^π(s,a) ) $$&lt;/li&gt;
&lt;li&gt;If the above condition does give degenerate results, the second condition is to add a penalty coefficient,  $-λ || R ||_1$ . It will make sure that the reward function remains zero in most places and non-zero at only some states with high profit.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The net reward search equation becomes:
$$
Maximize ∑_i min_{π∈丌} ~ { p( V^{π*}(s’) - V^{π_i}(s’) ) } $$
    $$s.t ~~ |α_i| ≤ 1,  ~~~~ i =1,2,..d $$
    $$ p(x)=x~when~x&amp;gt;0, ~else ~penalty*x $$
which can be solved with linear programming methods if reward functions are assumed to be linear.&lt;/p&gt;

&lt;p&gt;The paper explained three possible algorithms varying only w.r.t the underlying conditions.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Expert policy function $\pi(s)$ is known, state space $S$ is finite, and transition probabilities $P_{sa}$ are known. (&lt;strong&gt;Too ideal case&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Expert policy function $\pi(s)$ is known, state space $S$ is infinite, and transition probabilities $P_{sa}$ are known. (&lt;strong&gt;Too ideal case&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;m expert demonstrations/ trajectories are known. Transition probabilities are not known. (&lt;strong&gt;The realistic case&lt;/strong&gt;)&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;algorithm-flowchart&#34;&gt;Algorithm flowchart:&lt;/h3&gt;














&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;IRL_algo_layout.png&#34; data-caption=&#34;LIRL algorithm flowchart&#34;&gt;
&lt;img src=&#34;IRL_algo_layout.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    LIRL algorithm flowchart
  &lt;/figcaption&gt;


&lt;/figure&gt;


&lt;h3 id=&#34;experiments&#34;&gt;Experiments:&lt;/h3&gt;

&lt;p&gt;I used the MountainCar-v0 environment of OpenAI gym for training and testing the algorithm.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Expert Agent&lt;/strong&gt;: Used Q-learning algorithm with linear approximators to train the agent for generating expert policy.(This approach is used in numerous imitation learning problems as it becomes difficult for humans to generate expert policies in simulated environments as Mountain Car.)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Specifics&lt;/strong&gt;: Detailed specs can be found in the &lt;a href=&#34;https://vjg28.github.io/slides/irl-slides/&#34; target=&#34;_blank&#34;&gt;slides&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Refer to the &lt;a href=&#34;https://github.com/vjg28/Linear-Inverse-RL-algorithms&#34; target=&#34;_blank&#34;&gt;github repository&lt;/a&gt; for code and more details.&lt;/p&gt;

&lt;p&gt;












&lt;figure&gt;


  &lt;a data-fancybox=&#34;&#34; href=&#34;learnt_reward.png&#34; data-caption=&#34;Learned Reward function&#34;&gt;
&lt;img src=&#34;learnt_reward.png&#34; alt=&#34;&#34; &gt;&lt;/a&gt;


  
  
  &lt;figcaption&gt;
    Learned Reward function
  &lt;/figcaption&gt;


&lt;/figure&gt;

This was solely for educational purposes, so I didn&amp;rsquo;t try to exactly match the results of the paper. Mentioned in the slides are the differences and similarities of the experiment with the paper. Do let me know by mail or create an issue on github if you find any discrepancy in the code or any other issues.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Huffman Coding in ARM-v8</title>
      <link>https://vjg28.github.io/project/huffman-coding-arm/</link>
      <pubDate>Wed, 02 Oct 2019 01:05:22 +0530</pubDate>
      <guid>https://vjg28.github.io/project/huffman-coding-arm/</guid>
      <description></description>
    </item>
    
    <item>
      <title>Device for Ship Detection</title>
      <link>https://vjg28.github.io/project/device-for-ship-detection/</link>
      <pubDate>Thu, 04 Oct 2018 02:15:11 +0530</pubDate>
      <guid>https://vjg28.github.io/project/device-for-ship-detection/</guid>
      <description></description>
    </item>
    
    <item>
      <title>An example title</title>
      <link>https://vjg28.github.io/cv/</link>
      <pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate>
      <guid>https://vjg28.github.io/cv/</guid>
      <description>&lt;p&gt;Add your &lt;em&gt;content&lt;/em&gt; here&amp;hellip;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
